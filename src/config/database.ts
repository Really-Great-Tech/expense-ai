import { ConfigService } from '@nestjs/config';
import { DataSource, DataSourceOptions } from 'typeorm';
import * as dotenv from 'dotenv';
import { existsSync, readFileSync } from 'fs';
import { join } from 'path';
import { RDSIAMAuthManager } from './database-iam-auth';

// Load environment variables from .env file
dotenv.config();

const configService = new ConfigService();

// Simple logger for database config (before NestJS logger is available)
const log = (message: string, ...args: any[]) => {
  // eslint-disable-next-line no-console
  console.log(`[TypeORM Config] ${message}`, ...args);
};

const mysqlSslEnabled = configService.get<string>('MYSQL_SSL') === 'true';
const isProduction = configService.get<string>('NODE_ENV') === 'production';
const useIAMAuth = configService.get<string>('MYSQL_IAM_AUTH_ENABLED') === 'true';

/**
 * Robust path resolution for TypeORM entities and migrations
 * Supports all scenarios: local dev, watch mode, CLI operations, and production
 *
 * Strategy:
 * - Check if dist folder exists with compiled migrations
 * - If yes: use dist paths (production/post-build scenario)
 * - If no: use src paths (development with ts-node scenario)
 *
 * This prevents duplicate detection while supporting both environments
 */
const cwd = process.cwd();
const distSrcMigrations = join(cwd, 'dist', 'src', 'migrations');
const distMigrations = join(cwd, 'dist', 'migrations');
const srcMigrations = join(cwd, 'src', 'migrations');

// Check multiple possible locations for compiled migrations
const distMigrationsExist = existsSync(distSrcMigrations) || existsSync(distMigrations);

// Log the detected paths for debugging
log('Working directory:', cwd);
log('Checking migration paths:');
log('  - dist/src/migrations:', existsSync(distSrcMigrations));
log('  - dist/migrations:', existsSync(distMigrations));
log('  - src/migrations:', existsSync(srcMigrations));
log('Using compiled migrations:', distMigrationsExist);

// Use dist if it exists and has migrations, otherwise use src
// Include both possible dist locations for maximum compatibility
const entityPaths = distMigrationsExist
  ? ['dist/src/**/*.entity.js', 'dist/**/*.entity.js']
  : ['src/**/*.entity.ts'];

const migrationPaths = distMigrationsExist
  ? ['dist/src/migrations/*.js', 'dist/migrations/*.js']
  : ['src/migrations/*.ts'];

log('Entity paths:', entityPaths);
log('Migration paths:', migrationPaths);

/**
 * Get authentication password/token for database connection
 * Supports both traditional password and IAM authentication
 *
 * For Local MySQL (MYSQL_IAM_AUTH_ENABLED=false):
 * - Returns static password from MYSQL_PASSWORD env var
 * - Works with localhost MySQL installations
 *
 * For RDS IAM Authentication (MYSQL_IAM_AUTH_ENABLED=true):
 * - Returns empty string (placeholder)
 * - Actual token generated via authPlugin on each connection
 * - Requires SSL/TLS enabled
 */
const getPassword = (): string => {
  if (useIAMAuth) {
    // For IAM auth, return empty password
    // The actual token will be generated by the authPlugin
    return '';
  }

  // Traditional password authentication for local MySQL
  return configService.get<string>('MYSQL_PASSWORD', '');
};

/**
 * SSL Configuration for Aurora MySQL
 *
 * IAM authentication requires SSL/TLS. When IAM auth is enabled,
 * SSL is automatically enforced regardless of MYSQL_SSL setting.
 */
const getSslConfig = () => {
  // IAM auth requires SSL - force enable if IAM auth is used
  const sslEnabled = useIAMAuth || mysqlSslEnabled;

  if (!sslEnabled) {
    return false;
  }

  // Path to RDS CA certificate bundle
  const certPath = join(process.cwd(), 'certs', 'global-bundle.pem');
  const certPathAlt = join(__dirname, '..', '..', 'certs', 'global-bundle.pem');

  let ca: string | undefined;

  // Try to load certificate if it exists
  if (existsSync(certPath)) {
    ca = readFileSync(certPath, 'utf8');
  } else if (existsSync(certPathAlt)) {
    ca = readFileSync(certPathAlt, 'utf8');
  }

  // For IAM auth, always use SSL even if cert file is missing
  // (will rely on system CA certificates)
  return {
    rejectUnauthorized: isProduction && useIAMAuth, // Strict verification for IAM auth in production
    ca: ca, // CA certificate bundle (optional but recommended)
  };
};

/**
 * Get IAM auth configuration for connection pool
 * Only used when MYSQL_IAM_AUTH_ENABLED=true
 */
const getIAMAuthConfig = () => {
  if (!useIAMAuth) {
    return {};
  }

  const hostname = configService.get<string>('MYSQL_HOST');
  const port = parseInt(configService.get<string>('MYSQL_PORT', '3306'), 10);
  const username = configService.get<string>('MYSQL_USER');
  const region = configService.get<string>('AWS_REGION', 'us-east-1');

  if (!hostname || !username) {
    throw new Error(
      'Missing required IAM authentication configuration: ' +
        'MYSQL_HOST and MYSQL_USER must be set when MYSQL_IAM_AUTH_ENABLED=true',
    );
  }

  return {
    authPlugins: {
      mysql_clear_password: () => () => {
        // Generate IAM token for each connection
        // This function must return a Promise<Buffer> for mysql2
        return RDSIAMAuthManager.getAuthToken({
          hostname,
          port,
          username,
          region,
        }).then((token) => Buffer.from(token + '\0'));
      },
    },
  };
};

// Base DB configuration supporting both local and RDS IAM modes
const baseDBConfig: DataSourceOptions = {
  type: 'mysql' as const,
  host: configService.get<string>('MYSQL_HOST'),
  port: parseInt(configService.get<string>('MYSQL_PORT', '3306'), 10),
  username: configService.get<string>('MYSQL_USER'),
  password: getPassword(),
  database: configService.get<string>('MYSQL_DATABASE'),

  // Dynamically resolved paths based on environment
  entities: entityPaths,
  migrations: migrationPaths,

  // Explicitly name migration table for namespace isolation
  migrationsTableName: 'expense_ai_migrations',

  // CRITICAL: Production safeguards - NEVER enable synchronize in production
  synchronize: false,

  // Automatically run migrations on application startup
  // Migrations run in transactions (migrationsTransactionMode: 'each') for safety
  // This ensures database schema is always up-to-date with the application code
  migrationsRun: false,

  // Enable transaction per migration for rollback safety
  migrationsTransactionMode: 'each' as const,

  // SSL Configuration for Aurora MySQL
  // IAM authentication requires SSL/TLS
  ssl: getSslConfig(),

  // Aurora MySQL optimized settings
  timezone: 'Z', // Use UTC timezone
  charset: 'utf8mb4',

  // Connection timeout
  connectTimeout: 60000, // 60 seconds

  // Connection pool settings optimized for Aurora
  extra: {
    connectionLimit: parseInt(configService.get<string>('DB_CONNECTION_LIMIT', '20'), 10),
    queueLimit: parseInt(configService.get<string>('DB_QUEUE_LIMIT', '0'), 10),

    // Add IAM auth plugin if enabled
    ...getIAMAuthConfig(),

    // Aurora MySQL specific optimizations
    multipleStatements: false,
    dateStrings: false,
    supportBigNumbers: true,
    bigNumberStrings: false,
  },

  // Slow query logging threshold
  maxQueryExecutionTime: 60000,

  // Enhanced logging for migrations - includes schema and migration logs
  logging:
    configService.get<string>('TYPEORM_LOGGING') === 'all'
      ? 'all'
      : ['error', 'warn', 'schema', 'migration'],
  logger: 'advanced-console',
};

// Export base config for application use
export const dataSourceOptions: DataSourceOptions = baseDBConfig;

// Create and export DataSource instance for CLI operations
const dataSource = new DataSource(dataSourceOptions);
export default dataSource;
